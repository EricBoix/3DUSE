
## Concerning OSG-QT extension
**The context**:
 * VCity supports both QT4 and QT5.
 * **Coherence constraint**:
   Not surprisingly OSG-QT depends both on OSG and QT. As Robert Osfield puts it (refer to this [OSG discussion thread](http://forum.openscenegraph.org/viewtopic.php?t=13713)):
   ```
   If you application is using the osgQt library and this lib is linked
   to Qt4 then mixing the viability of mixing Qt5 libs in your application
   will be down to Qt4/5 compatibility, something I can't answer as I'm no
   Qt expert but I guess it's reasonable to assume that this could cause
   problems.
   If you can't mix Qt5 and Qt4 within a single application then you'll
   either have to rebuild the OSG against Qt5 or avoid using components
   of the OSG that use Qt - primarily this is osgQt but there a few
   plugins use it too.
   ```
   **Conclusion (coherence constraint)**: if we build our application to say QT4 then the OSG-QT extension the application has to link against has to be build against QT4 also (that is the same QT version)
 * **Packager's choice constraint**
   As of 2016, QT4 is still the dominant version in terms of usages. Binary distribution packagers facing the QT4/QT5 choice, when they do provide OSG with the QT extension, will thus most often choose to link against QT4.
 * **Travis is unable to recompile OSG-QT `--with-qt` option**
   The OSG developers respect the `DESIRED_QT_VERSION` good pratice ([more]( http://stackoverflow.com/questions/20317354/how-to-compile-open-scene-graph-3-2-with-qt-5-1-and-cmake)) which enables packagers to provide optional builds from sources. For example on OSX, OSGQT can be obtained with `brew install open-scene-graph --with-qt` for QT4 linking and `brew install open-scene-graph --with-qt5` for QT5 linking. Alas such rebuilds of OSG from source take quite some time and Travis usually exits from the above brew install directives prior to completion (with a message like `No output has been received in the last 10m0s, this potentially indicates a stalled build or something wrong with the build itself.`).
   **Conclusion (partial)**: we have to deal with the default binary package choices.
 * **Discovering the underlying QT version of OSGQT is hard for CMake**
   Alas it is not straighforward for a cmake project to know whether the installed OSG-QT extension they discover natively with `find_package()` was built against QT4 or QT5.  
 * **Mismatchs are discovered only at runtime**
  As [this discussion](http://forum.openscenegraph.org/viewtopic.php?t=14999) explains it, if there is a **mismatch between the QT version** of your application and the version used by the OSG-QT binary package then your application won't detect it at build/link stage and your **application will crash at run time.**
 * Note: this QT4/QT5 incompatiblity mix is symetric. For example if you application requires linking against QT4 but the installed version of OSG QT extension was linked against QT5, then you will have to rebuild # OSG against QT4.

**Discussion**:
VCity's CMakeFile designer has too choose between various options he decides to offer to his users:
 1. the **you're alone** service level: 
   this consists in requiring the project builder to provide an OSG-QT extension linked against the same version of QT that he whishes VCity to use. Failure to provide OSGQT will be reported (and build stoped), but a version mismatch won't be detected by cmake at buld time. The ctest will fail but leaving the user with very few clues of what is going on. Note that such level won't allow VCity to be built on Travis for OSX (as of 10.11.X Homebrew provided OSG binary package doesn't come up with any QT support at all, and rebuilding from source is killed on duty by Travis as above mentionned).
 2. the **embark OSGQT** service level:
   VCity can choose to embark its own copy of the OSG-Qt extension. CMake could then ignore any packaging system installed version of OSGQt and allways use its own copy:
    * The advantage of this strategy is that there is no possible mismatch since OSG-Qt extension is always recompiled by VCity against the chosen Qt version. Hence build and run are robust.
    * The drawback of systematically ignoring the native OSGQT is for VCity developers not being able to confront VCity to the current version of OSGQT. At some point the OSG provided OSGQT will drift appart from VCity's embarked version without convenient build/test means to measure the drift of VCity towards the official OSG version.
 3. the **embark OSQT and letting the user manually choose** service level:
   This level can be described as the "embark OSGQT" with the right to choose for the CMake user. This solution still has:
   * the "embark/fork OSGQT" associated risks and also the "you're alone" inconveniences i.e. a "not so aware" user will face run (load) time failures whitout much clues...
   * the advantage that an aware user (including developes) will have the freedom to make his own trials against the natively build OSGQT.
 4. the "automatic plan B" service level:
   The CMakeFiles are here able to detect the mismatch and automatically fold to back to the embarked copy of OSGQT as plan B:
    * the advantage is build/run robustness
    * the drawack is that the CMakeFIle developer is facing the hard/daunting task of detecting which version of QT underlies OSQT.
 5. the "automatic yet unpluggable plan B" service level:
    This level is basically the previous one with the additional possibility of manually switching to the emabarked version.

**Conclusion**
For the time being VCity resolves to the "embark OSQT and letting the user manually choose" service level (mainly because automatic detection looks very hard to realize).